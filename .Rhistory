(7*2/9.81)^0.5
ggplot(Dataframe,aes(as.factor(ObjectMotion),SDResponse)) +
geom_point(size = 5) +
facet_wrap(.~ObserverDirection) +
ylab("SD Response (s)") +
xlab("Target Motion Direction") +
scale_x_discrete(labels = c("up", "right", "down", "left"))
###Pull the whole repository and paste the path to the the local GitHub repository here:
require(dplyr)
require(tidyverse)
require(lme4)
require(cowplot)
theme_set(theme_cowplot())
set.seed(912)
ID = paste0("s",1:16)
SelfMotion = 1:5
ObjectMotion = 1:4
VisibleTimes = c(0.4,0.5,0.6)
OccludedTimes = c(0.4,0.5,0.6)
reps = 1:16
####We need:
#- Higher precision for downwards target motion than for the other three target directions (+0.05 if target not downwards)
#- Lower precision when observer moves in the same or opposite direction as target (+0.05)
#- Highest precision when the observer doesn't move & target moves downwards (baseline; +0.00)
#- slightly lower precision when the observer doesnt move & the target does not move downwards (0.02)
#- Medium precision when the observer moves orthogonal to target (+0.03)
#- Bias to respond too late for upwards target motion; (+0.1)
#- also some bias for sidewards target motion; (+0.05)
#- no bias for downwards motion (+0.00)
#- bias to respond too late when observer moves in the same direction as target (+0.1)
#- bias to respond too early when observer moves opposite to the target (-0.1)
#- no bias when the observer moves orthogonal to the target (baseline; 0.00)
SimulateDataframe = function(ID,SelfMotion,ObjectMotion,VisibleTimes,OccludedTimes,reps){
Dataframe = expand.grid(ID=ID,
SelfMotion=SelfMotion,
ObjectMotion=ObjectMotion,
reps = reps,
VisibleTimes = VisibleTimes,
OccludedTimes = OccludedTimes)
Dataframe$WF = 0.1
Dataframe$Mean = Dataframe$OccludedTimes
Dataframe = Dataframe %>%
group_by(ID) %>%
mutate(WF = abs(WF*abs(rnorm(1,1,0.1))),
Mean = Mean + rnorm(1,0,0.01))
Dataframe = Dataframe %>%
mutate(WF_Factor =
case_when(
SelfMotion == 1 & ObjectMotion == 1 ~ 0.15, #self and object motion parallel
SelfMotion == 1 & ObjectMotion == 2 ~ 0.12, #self and object motion orthogonal
SelfMotion == 1 & ObjectMotion == 3 ~ 0.12, #self and object motion parallel, but object motion gravitational
SelfMotion == 1 & ObjectMotion == 4 ~ 0.12, #self and object motion orthogonal
SelfMotion == 2 & ObjectMotion == 1 ~ 0.12, #self and object motion orthogonal
SelfMotion == 2 & ObjectMotion == 2 ~ 0.15, #self and object motion parallel
SelfMotion == 2 & ObjectMotion == 3 ~ 0.10, #self and object motion orthogonal, but object motion gravitational
SelfMotion == 2 & ObjectMotion == 4 ~ 0.15, #self and object motion parallel
SelfMotion == 3 & ObjectMotion == 1 ~ 0.15, #self and object motion parallel
SelfMotion == 3 & ObjectMotion == 2 ~ 0.12, #self and object motion orthogonal
SelfMotion == 3 & ObjectMotion == 3 ~ 0.13, #self and object motion parallel, but object motion gravitational
SelfMotion == 3 & ObjectMotion == 4 ~ 0.12, #self and object motion orthogonal
SelfMotion == 4 & ObjectMotion == 1 ~ 0.12, #self and object motion orthogonal
SelfMotion == 4 & ObjectMotion == 2 ~ 0.15,  #self and object motion parallel
SelfMotion == 4 & ObjectMotion == 3 ~ 0.10, #self and object motion orthogonal, but object motion gravitational
SelfMotion == 4 & ObjectMotion == 4 ~ 0.15, #self and object motion parallel
SelfMotion == 5 & ObjectMotion == 1 ~ 0.10, #observer static
SelfMotion == 5 & ObjectMotion == 2 ~ 0.10, #observer static
SelfMotion == 5 & ObjectMotion == 3 ~ 0.08, #observer static and object motion gravitational
SelfMotion == 5 & ObjectMotion == 4 ~ 0.10), #observer static
Mean_Factor =
case_when(
SelfMotion == 1 & ObjectMotion == 1 ~ 1.20, #+0.1 because you think it slows down (internal model of gravity), +0.1 self-motion in same direction as object motion
SelfMotion == 1 & ObjectMotion == 2 ~ 1.05, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late
SelfMotion == 1 & ObjectMotion == 3 ~ 0.98, #-0.02 because you move opposite to the target, but the effect is diminished because its gravitational motion
SelfMotion == 1 & ObjectMotion == 4 ~ 1.05, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late
SelfMotion == 2 & ObjectMotion == 1 ~ 1.10, #+0.1 because you think it slows down (internal model of gravity)
SelfMotion == 2 & ObjectMotion == 2 ~ 1.15, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late, +0.1 because self-motion in same direction as object motion
SelfMotion == 2 & ObjectMotion == 3 ~ 1.00, #accurate because gravity
SelfMotion == 2 & ObjectMotion == 4 ~ 0.95, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late; -0.1 because self-motion in opposite direction of object motion
SelfMotion == 3 & ObjectMotion == 1 ~ 1.00, #+0.1 because you think it slows down (internal model of gravity); -0.1 because self-motion in opposite direction of object motion
SelfMotion == 3 & ObjectMotion == 2 ~ 1.05, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late
SelfMotion == 3 & ObjectMotion == 3 ~ 1.02, #+0.02 because you move in the same direction as the target, but the effect is diminished because its gravitational motion
SelfMotion == 3 & ObjectMotion == 4 ~ 1.05, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late
SelfMotion == 4 & ObjectMotion == 1 ~ 1.10, #+0.1 because you think it slows down (internal model of gravity);
SelfMotion == 4 & ObjectMotion == 2 ~ 0.95, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late; -0.1 because self-motion in opposite direction of object motion
SelfMotion == 4 & ObjectMotion == 3 ~ 1.00, #accurate because gravity
SelfMotion == 4 & ObjectMotion == 4 ~ 1.15, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late; +0.1 because self-motion in same direction as object motion
SelfMotion == 5 & ObjectMotion == 1 ~ 1.10, #+0.1 because you think it slows down (internal model of gravity)
SelfMotion == 5 & ObjectMotion == 2 ~ 1.05, #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late
SelfMotion == 5 & ObjectMotion == 3 ~ 1.00, #1 because accurate *shrugs*
SelfMotion == 5 & ObjectMotion == 4 ~ 1.05) #+0.05 because its accelerating, but you cant deal with acceleration, so youre too late
)
Dataframe = Dataframe %>%
mutate(response = rnorm(length(Mean),Mean*Mean_Factor,Mean*WF_Factor))
Dataframe
}
Dataframe = SimulateDataframe(ID=ID,SelfMotion=SelfMotion,ObjectMotion=ObjectMotion,VisibleTimes=VisibleTimes,OccludedTimes=OccludedTimes,reps=reps)
Dataframe = Dataframe %>%
group_by(ObjectMotion,SelfMotion) %>%
mutate(Ratio = response/OccludedTimes,
MeanResponse = mean(Ratio),
SDResponse = sd(Ratio))
Dataframe = Dataframe %>%
mutate(ObserverDirection =
case_when(
SelfMotion == 1 ~ "Observer up",
SelfMotion == 2 ~ "Observer right",
SelfMotion == 3 ~ "Observer down",
SelfMotion == 4 ~ "Observer left",
SelfMotion == 5 ~ "Observer static",
)
)
Dataframe$ObserverDirection = factor(Dataframe$ObserverDirection, levels=c('Observer up','Observer right','Observer down','Observer left', "Observer static"))
ggplot(Dataframe,aes(as.factor(ObjectMotion), MeanResponse)) +
geom_point(size = 5) +
facet_wrap(.~ObserverDirection) +
xlab("Ratio Response/Occlusion (s)") +
scale_x_discrete(labels = c("up", "right", "down", "left"))
ggplot(Dataframe,aes(as.factor(ObjectMotion),SDResponse)) +
geom_point(size = 5) +
facet_wrap(.~ObserverDirection) +
ylab("SD Response (s)") +
xlab("Target Motion Direction") +
scale_x_discrete(labels = c("up", "right", "down", "left"))
###Pull the whole repository
require(dplyr)
require(tidyverse)
require(lme4)
require(ggplot2)
require(cowplot)
theme_set(theme_cowplot())
binomial_smooth <- function(...) {
geom_smooth(method = "glm", method.args = list(family = "binomial"), ...)}
source("Utilities/parabolic.r")
source("Utilities/functions.r")
source("Utilities/colourschemes.r")
set.seed(912)
plot_grid(hist(plots[1]),hist(plots[2]),hist(plots[3]),hist(plots[4]),hist(plots[5]))
data.frame()
sd(air_drag$terrorratio[air_drag$airdrag == "Airdrag"])
libraries <- c("cowplot","tidyverse","grid","gridExtra","lme4","lmerTest",
"ggpubr","apastats","rstatix", "rstan", "brms", "Hmisc")
# Where is this script?
invisible(lapply(libraries, function(x) {
if(!require(x, character.only = T, quietly = T)) {
install.packages(x)
require(x, character.only = T)
}
}
))
rm(libraries)
#####optimize setup for Bayesian Linear Models (rstan/brms)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7')
Where_Am_I <- function(path=T){
if (path == T){
dirname(rstudioapi::getSourceEditorContext()$path)
}
else {
rstudioapi::getSourceEditorContext()$path
}
}
#set ggplot theme
theme_set(theme_cowplot())
#set working directory to the folder that contains this file
setwd(Where_Am_I())
#load necessary functions
source("Utilities/Funs.R")
#we pasted all data into one file, which is loaded here
collapsed <- read.table(file = "Data/All_Data_Air_Drag.txt", header = T)
air_drag <-  collapsed %>%
select(trial,x_max,t_max,vx, #take all relevant data from the data file
x_max_model,t_max_model, ball,cond_size,r,air_drag,label,
random_x,rtime_timing,rtime_spatial,ball_x_spatial,
id,TTC,visible) %>%
#x_max is the point where the ball hit the table
#t_max is the time at which the ball hit the table
#x_max_model
#x_max_model is the x position where participants should believe the ball hit the table, if they had a representation of air drag
#t_max_model is the moment participants should believe the ball hit the table, if they had a representation of air drag
#ball indicates whether the ball had a tennis ball texture or a basketball texture
#cond_size indicates whether the texture of the ball was congruent with its size and other air drag properties
#r is the radius of the target
#air_drag indicates whether airdrag was simulated in the first part of the trajectory or not
#label is a categorical variable with 48 levels, one for each combination of horizontal velocity,
#air drag yes/no, ball type, congruency category and time-to-contact
#random_x is the initial position of the ball the observers used to give their spatial response
#rtime_timing is the moment from movement onset that observers pressed the button for the timing task
#rtime_spatial is the time between appearance of the ball used for the spatial response until they
#pressed the button again to indicate they were satisfied with the position of the ball, i. e. the time
#it took them to give their answer
#ball_x_spatial is where participants indicated the ball hit the table
#id are participant ids
#TTC are the overall flight durations
#visible denotes the time where the target became invisible
mutate(
#timing error with respect to the real time of impact:
#we subtract 0.049s from the temporal responses because we have seen before that our projectors inrtoduce a delay of 0.049s
terror = rtime_timing-t_max-0.049,
#spatial error with respect to real point of impact:
xerror = ball_x_spatial - x_max,
#how long was the ball occluded:
OccludedDuration = t_max-visible,
#what percentage of the trajectory was the ball occluded:
OccludedPercentage = visible/t_max,
#for what length was the ball occluded in spatial terms:
OccludedDistance = case_when(
air_drag == 1 ~ x_max-(x_max/2+vx*0.8*t_max*(OccludedPercentage-0.5)), #vx is down to 80% of the original speed in air drag condition
air_drag == 0 ~ x_max-(x_max/2+vx*t_max*(OccludedPercentage-0.5))),
#the temporal error normalized by the duration of the occlusion:
terrorratio = (OccludedDuration+terror) / OccludedDuration,
#the spatial error normalized by the length of the occlusion:
xerrorratio = (OccludedDistance+xerror) / OccludedDistance,
#neater way of denoting variables:
condsize = factor(cond_size,levels = c("cong","incongr"),
labels = c("Congruent","Incongruent")),
ball = factor(ball,levels = c("tennis","basket"),
labels = c("Tennis","Basket")),
airdrag = case_when(air_drag == 1 ~ "Airdrag",
air_drag == 0 ~ "NoAirdrag"))
#how many data points to we have before getting rid of outliers?
nAllTrials = length(air_drag$trial)
air_drag = air_drag %>%
group_by(id,label) %>%
filter(terrorratio < 4 & terrorratio > 0.25,
xerrorratio < 4 & xerrorratio > 0.25)
#how many trials did we lose?
nTrialsFirstStep = nAllTrials - length(air_drag$trial)
nTrialsFirstStep/nAllTrials
air_drag = air_drag %>%
group_by(id,label) %>%
filter(trim(terror, filter = T)) %>%
filter(trim(xerror, filter = T))
nTrialsSecondStep = nAllTrials - nTrialsFirstStep - length(air_drag$trial)
nTrialsSecondStep/(nAllTrials - nTrialsFirstStep)
#trim
?trim
#number of excluded trials
nTrialsThirdStep = nAllTrials - nTrialsSecondStep - nTrialsFirstStep - length(air_drag$trial)
nTrialsSecondStep/(nAllTrials - nTrialsFirstStep)
lala = boxplot.stats(air_drag$terror)
?boxplot.stats
####################################################################
################Confirmatory Analyses###############################
####################################################################
##############Hypothesis 1: Do Humans have a Representation of Air Drag?
###Hypothesis 1: Temporal Error
#quick visualization:
ggplot(air_drag, aes(airdrag,terrorratio,color=airdrag)) +
geom_violin() +
geom_hline(yintercept=1) +
geom_boxplot()
#Are temporal error different between airdrag present/absent?
H1_Temporal <- lmer(terrorratio ~ airdrag + (1|id),
data = air_drag)
H1_Temporal_Null <- lmer(terrorratio ~ (1|id),
data = air_drag)
anova(H1_Temporal,H1_Temporal_Null)
summary(H1_Temporal)
#are temporal errors in either condition centered around 1?
H1_Temporal_Intercept1 <- lmer(terrorratio-1 ~ 0 + (1|id),
data = air_drag[air_drag$airdrag == "Airdrag",])
H1_Temporal_Intercept1_Null <- lmer(terrorratio-1 ~ (1|id),
data = air_drag[air_drag$airdrag == "Airdrag",])
anova(H1_Temporal_Intercept1,H1_Temporal_Intercept1_Null)
summary(H1_Temporal_Intercept1)
#not for the Airdrag: Present condition
H1_Temporal_Intercept2 <- lmer(terrorratio-1 ~ 0 + (1|id),
data = air_drag[air_drag$airdrag == "NoAirdrag",])
H1_Temporal_Intercept2_Null <- lmer(terrorratio-1 ~ (1|id),
data = air_drag[air_drag$airdrag == "NoAirdrag",])
anova(H1_Temporal_Intercept2,H1_Temporal_Intercept2_Null)
summary(H1_Temporal_Intercept2)
#not for the Airdrag: Absent condition either
#Hypothesis 1: Bayesian Linear Mixed Models
fit1 <- brm(bf(terrorratio ~ airdrag + (1|id),
sigma ~ airdrag + (1|id)),
data = air_drag, family = gaussian())
###Hypothesis 1b: Spatial Error
#quick visualization
ggplot(air_drag, aes(airdrag,xerrorratio,color = airdrag)) +
geom_violin() +
geom_hline(yintercept=1) +
geom_boxplot()
#Are spatial errors different between airdrag present/absent?
H1_Spatial <- lmer(xerrorratio ~ airdrag + (1|id),
data = air_drag)
H1_Spatial_Null <- lmer(xerrorratio ~ (1|id),
data = air_drag)
anova(H1_Spatial,H1_Spatial_Null)
summary(H1_Spatial)
#are temporal errors in either condition centered around 1?
H1_SpatialIntercept1 <- lmer(xerrorratio-1 ~ 0 + (1|id),
data = air_drag[air_drag$airdrag == "Airdrag",])
H1_SpatialIntercept1_Null <- lmer(xerrorratio-1 ~ (1|id),
data = air_drag[air_drag$airdrag == "Airdrag",])
anova(H1_SpatialIntercept1,H1_SpatialIntercept1_Null)
summary(H1_Spatial)
H1_Spatial_Intercept2 <- lmer(xerrorratio-1 ~ 0 + (1|id),
data = air_drag[air_drag$airdrag == "NoAirdrag",])
H1_Spatial_Intercept2_Null <- lmer(xerrorratio-1 ~ (1|id),
data = air_drag[air_drag$airdrag == "NoAirdrag",])
anova(H1_Spatial_Intercept2,H1_Spatial_Intercept2_Null)
summary(H1_Spatial_Intercept1)
#Hypothesis 1: Bayesian Linear Mixed Models
hypothesis(fit1,c("abs(Intercept-1) < abs(Intercept+airdragNoAirdrag-1)"))
fit2 <- brm(bf(xerrorratio ~ airdrag + (1|id),
sigma ~ airdrag + (1|id)),
data = air_drag, family = gaussian())
hypothesis(fit2,c("abs(Intercept-1) < abs(Intercept+airdragNoAirdrag-1)"))
##############Hypothesis 2: Does the texture of the ball have any impact?
###Hypothesis 2: Temporal Error
#quick visualization:
ggplot(air_drag, aes(condsize,terrorratio, color = ball)) +
geom_violin() +
geom_boxplot()
H2_Time <- lmer(terrorratio ~ ball*condsize + (1|id),
data = air_drag[air_drag$airdrag == "Airdrag",])
H2_Time_Null <- lmer(terrorratio ~ ball + condsize + (1|id),
data = air_drag[air_drag$airdrag == "Airdrag",])
anova(H2_Time,H2_Time_Null)
summary(H2_Time)
#no difference
##space
ggplot(air_drag, aes(ball,xerrorratio, color = condsize)) +
geom_violin() +
geom_boxplot()
H2_Space <- lmer(xerrorratio ~ ball*condsize + (1|id),
data = air_drag[air_drag$airdrag == "Airdrag",])
H2_Space_Null <- lmer(xerrorratio ~ ball + condsize + (1|id),
data = air_drag[air_drag$airdrag == "Airdrag",])
anova(H2_Space,H2_Space_Null)
summary(H2_Space)
#yes difference
sd(air_drag$terrorratio[air_drag$airdrag == "Airdrag"])
sd(air_drag$terrorratio[air_drag$airdrag == "NoAirdrag"])
sd(air_drag$xerrorratio[air_drag$airdrag == "Airdrag"])
sd(air_drag$xerrorratio[air_drag$airdrag == "NoAirdrag"])
air_drag %>%
group_by(id,label) %>%
mutate(sd_T = sd(terrorratio),
sd_X = sd(xerrorratio)) %>%
slice(1) %>%
group(airdrag) %>%
mutate(mean_sd_T = sd(sd_T),
mean_sd_X = sd(sd_X)) %>%
slice(1)
air_drag %>%
group_by(id,label) %>%
mutate(sd_T = sd(terrorratio),
sd_X = sd(xerrorratio)) %>%
slice(1) %>%
group_by(airdrag) %>%
mutate(mean_sd_T = sd(sd_T),
mean_sd_X = sd(sd_X)) %>%
slice(1)
air_drag %>%
group_by(id,label) %>%
mutate(sd_T = sd(terrorratio),
sd_X = sd(xerrorratio)) %>%
slice(1) %>%
group_by(airdrag) %>%
mutate(mean_sd_T = sd(sd_T),
mean_sd_X = sd(sd_X)) %>%
slice(1) %>%
select(mean_sd_T,mean_sd_X)
air_drag %>%
group_by(id,label) %>%
mutate(sd_T = sd(terrorratio),
sd_X = sd(xerrorratio)) %>%
slice(1) %>%
group_by(condsize) %>%
mutate(mean_sd_T = sd(sd_T),
mean_sd_X = sd(sd_X)) %>%
slice(1) %>%
select(mean_sd_T,mean_sd_X)
air_drag %>%
group_by(id,label) %>%
mutate(sd_T = sd(terrorratio),
sd_X = sd(xerrorratio)) %>%
slice(1) %>%
group_by(r) %>%
mutate(mean_sd_T = sd(sd_T),
mean_sd_X = sd(sd_X)) %>%
slice(1) %>%
select(mean_sd_T,mean_sd_X)
air_drag %>%
group_by(condsize) %>%
mutate(mean_T = mean(terrorratio),
mean_X = mean(xerrorratio)) %>%
slice(1) %>%
select(mean_T,mean_X)
air_drag %>%
group_by(r) %>%
mutate(mean_T = mean(terrorratio),
mean_X = mean(xerrorratio)) %>%
slice(1) %>%
select(mean_T,mean_X)
Expl_BiasVsPrecision_Within_Space <- lmer(xerrorratio ~ SDratio_x + (1|id),
data = air_drag_VariabilityvsBias)
Expl_BiasVsPrecision_Within_Space_Null <- lmer(xerrorratio ~  (1|id),
data = air_drag_VariabilityvsBias)
## End(Not run)
roh = 1.225
cd = 0.535
r = 0.12
D = 0.5 * roh * cd * pi * r^2
m = 0.6
vx = 3.5
vy = 6.86
g = 9.81
for (i in seq(0,1.4*0.575,0.01)){
vt = (vx^2+vy^2)^0.5
ax = -(D/m)*vt*vx
ay = g - (D/m)*vt*vy
vx = vx  + ax  * 0.01
vy = vy + ay  * 0.01
print(i)
}
###Relationship between variability and bias
air_drag_sum <- air_drag %>% #make new data frame with means for the following values
group_by(TTC,vx,id,air_drag,ball,cond_size) %>%
mutate(sd_timing = sd(terror),
sd_spatial = sd(xerror),
visible = mean(visible),
terrorratio = mean(terrorratio),
xerrorratio = mean(xerrorratio),
SDratio_t = sd_timing/mean(OccludedDuration),
SDratio_x = sd_spatial/mean(OccludedDistance),
t_max = mean(t_max),
x_max = mean(x_max),
terror = mean(terror),
xerror= mean(xerror))
air_drag_VariabilityvsBias <- air_drag_sum %>%
group_by(TTC,vx,id,air_drag,ball,cond_size) %>%
slice(1)
#Overall Variability (between and within together)
Expl_BiasVsPrecision_Overall_Time <- lm(terrorratio ~ SDratio_t,
data = air_drag_VariabilityvsBias)
summary(Expl_BiasVsPrecision_Overall_Time)
Expl_BiasVsPrecision_Overall_Space <- lm(xerrorratio ~ SDratio_x,
data = air_drag_VariabilityvsBias)
summary(Expl_BiasVsPrecision_Overall_Space)
#within Variability
Expl_BiasVsPrecision_Within_Time <- lmer(terrorratio ~ SDratio_t + (1|id),
data = air_drag_VariabilityvsBias)
Expl_BiasVsPrecision_Within_Time_Null <- lmer(terrorratio ~  (1|id),
data = air_drag_VariabilityvsBias)
anova(Expl_BiasVsPrecision_Within_Time,Expl_BiasVsPrecision_Within_Time_Null)
summary(Expl_BiasVsPrecision_Within_Time)
Expl_BiasVsPrecision_Within_Space <- lmer(xerrorratio ~ SDratio_x + (1|id),
data = air_drag_VariabilityvsBias)
Expl_BiasVsPrecision_Within_Space_Null <- lmer(xerrorratio ~  (1|id),
data = air_drag_VariabilityvsBias)
anova(Expl_BiasVsPrecision_Within_Space,Expl_BiasVsPrecision_Within_Space_Null)
#within Variability
Expl_BiasVsPrecision_Within_Time <- lmer(terrorratio ~ SDratio_t + (1|id),
data = air_drag_VariabilityvsBias)
Expl_BiasVsPrecision_Within_Time_Null <- lmer(terrorratio ~  (1|id),
data = air_drag_VariabilityvsBias)
anova(Expl_BiasVsPrecision_Within_Time,Expl_BiasVsPrecision_Within_Time_Null)
summary(Expl_BiasVsPrecision_Within_Time)
Expl_BiasVsPrecision_Within_Space <- lmer(xerrorratio ~ SDratio_x + (1|id),
data = air_drag_VariabilityvsBias)
Expl_BiasVsPrecision_Within_Space_Null <- lmer(xerrorratio ~  (1|id),
data = air_drag_VariabilityvsBias)
anova(Expl_BiasVsPrecision_Within_Space,Expl_BiasVsPrecision_Within_Space_Null)
summary(Expl_BiasVsPrecision_Within_Space)
Expl_BiasVsPrecision_Within2_Space <- lmer(xerrorratio ~ SDratio_x + (1|id),
data = air_drag_VariabilityvsBias)
Expl_BiasVsPrecision_Within2_Space_Null <- lmer(xerrorratio ~  (1|id),
data = air_drag_VariabilityvsBias)
anova(Expl_BiasVsPrecision_Within_Space,Expl_BiasVsPrecision_Within_Space_Null)
Expl_BiasVsPrecision_Within2_Space <- lmer(xerrorratio ~  (SDratio_x|id),
data = air_drag_VariabilityvsBias)
Expl_BiasVsPrecision_Within2_Space_Null <- lmer(xerrorratio ~  (1|id),
data = air_drag_VariabilityvsBias)
anova(Expl_BiasVsPrecision_Within_Space,Expl_BiasVsPrecision_Within_Space_Null)
summary(Expl_BiasVsPrecision_Within_Space)
coef(Expl_BiasVsPrecision_Within_Space)
anova(Expl_BiasVsPrecision_Within_Space2,Expl_BiasVsPrecision_Within_Space_Null2)
summary(Expl_BiasVsPrecision_Within_Space2)
anova(Expl_BiasVsPrecision_Within2_Space,Expl_BiasVsPrecision_Within2_Space_Null)
summary(Expl_BiasVsPrecision_Within2_Space)
coef(Expl_BiasVsPrecision_Within2_Space)
for (i in seq(0,1.4*0.575,0.01)){
vt = (vx^2+vy^2)^0.5
ax = -(D/m)*vt*vx
ay = g - (D/m)*vt*vy
vx = vx  + ax  * 0.01
vy = vy + ay  * 0.01
print(i)
}
vx
## End(Not run)
roh = 1.225
cd = 0.535
r = 0.12
D = 0.5 * roh * cd * pi * r^2
m = 0.6
vx = 3.5
vy = 6.86
g = 9.81
for (i in seq(0,1.4*0.575,0.01)){
vt = (vx^2+vy^2)^0.5
ax = -(D/m)*vt*vx
ay = g - (D/m)*vt*vy
vx = vx  + ax  * 0.01
vy = vy + ay  * 0.01
print(i)
}
vx
